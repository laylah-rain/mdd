(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mdd = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const ParserHTML = require('./parser_html.js');

/**
 * Parsing & Compiling
 */
module.exports = class GeneratorHTML {
  constructor() {
    
  }

  /**
   * Static Parse Method
   */
  static generator(tokens) {

    var dictionary_html= [];

    for (var x in tokens){
      var limitedTokens=[tokens[x]];
      dictionary_html.push({type: tokens[x].type, html: ParserHTML.parse(limitedTokens)})
    }

    var out = dictionary_html;
    return out;
  }


};

},{"./parser_html.js":4}],2:[function(require,module,exports){
const Tokenizer = require('./tokenizer.js');
const { block } = require('./rules.js');

/**
 * Block Lexer
 */
module.exports = class Lexer {
  
  constructor(options) {
    this.tokens = [];
    this.tokenizer = new Tokenizer();
  }

  /**
   * Static Lex Method
   */
  static lex(src) {
    const lexer = new Lexer();
    return lexer.lex(src);
  }


  /**
   * Preprocessing
   */
  lex(src) {
    this.createTokens(src, this.tokens);
    return this.tokens;
  }

  /**
   * Lexing
   */
  createTokens(src, tokens = []) {

    let token;

    while (src) {

      // ARTICLE_NOTE
         if (token = this.tokenizer.article_note(src)) {
          src = src.replace(token.raw,'');
          console.log("ENTRO A EXTRA NOTE")
          console.log(token)
          token.tokens = Lexer.lex(token.text)
          tokens.push(token);
          continue;
      }

      // LANGUAGE
      if (token = this.tokenizer.language(src)) {
        src = src.replace(token.metadata,'');
        tokens.push(token);
        continue;
      }

      // CSS
      if (token = this.tokenizer.css(src)) {
        src = src.replace(token.metadata,'');
        tokens.push(token);
        continue;
      }

      // TITLE
      if (token = this.tokenizer.title(src)) {
        src = src.replace(token.metadata,'');
        tokens.push(token);
        continue;
      }

      // FAVICON
      if (token = this.tokenizer.favicon(src)) {
        src = src.replace(token.metadata,'');
        tokens.push(token);
        continue;
      }

      // COVER
      if (token = this.tokenizer.cover(src)) {
        src = src.replace(token.metadata,'');
        tokens.push(token);
        continue;
      }

      // FOOTER
      if (token = this.tokenizer.footer(src)) {
        src = src.replace(token.information,'');
        var items = token.list.split("- ");
        items.shift();
        token.internal=items;

        for (let x in items){
          token.internal[x]= Lexer.lex(items[x]);
        }

        tokens.push(token);
        continue;
      }

      // NAVBAR
      if (token = this.tokenizer.navbar(src)) {
        src = src.replace(token.information,'');
        var items = token.list.split(/\s*- /);
        items.shift();
        token.internal=items;

        for (let x in items){
          token.internal[x]= Lexer.lex(items[x]);
        }

        tokens.push(token);
        continue;
      }

      // META
      if (token = this.tokenizer.meta(src)) {
        src = src.replace(token.metadata,'');
        tokens.push(token);
        continue;
      }

      // BODY
      if (token = this.tokenizer.body(src)) {
        token.internal = Lexer.lex(token.body);
        tokens.push(token);
        break;
      }


      // IMAGE_LINK_SAMETAB
      if (token = this.tokenizer.image_link_sametab(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }


      // IMAGE_LINK
      if (token = this.tokenizer.image_link(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // IMAGE_CAPTION
      if (token = this.tokenizer.image_caption(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // IMAGE_NO_CAPTION
      if (token = this.tokenizer.image_no_caption(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // IMAGE_COVER
      if (token = this.tokenizer.image_cover(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // AUDIO
      if (token = this.tokenizer.audio(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }


      // HEADING_DESCRIPTION
      if (token = this.tokenizer.heading_description(src)) {
        src = src.substring(token.raw.length);
        token.tokens_title = Lexer.lex(token.text)
        token.tokens_description = Lexer.lex(token.description)
        tokens.push(token);
        continue;
      }


      // HEADING
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }


      // BLOCKQUOTE
      if (token = this.tokenizer.blockquote(src)) {
        src = src.replace(token.raw,'');
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // COMMENT
      if (token = this.tokenizer.comment(src)) {
        src = src.replace(token.raw,'');
        tokens.push(token);
        continue;
      }

      // LIST1
      if (token = this.tokenizer.list1(src)) {
        console.log("LISTAAAAAAAA")
        src = src.replace(token.raw,'');
        var items = token.list.split(/\s*- /);
        items.shift();
        token.internal=items;
        
        for (let x in items){
          token.internal[x]= Lexer.lex(items[x]);
        }
        tokens.push(token);
        continue;
      }

      // NOTE
      if (token = this.tokenizer.note(src)) {
        src = src.substring(token.raw.length);
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // MARKER
      if (token = this.tokenizer.marker(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // PARAGRAPH
      if (token = this.tokenizer.paragraph(src)) {
        src = src.substring(token.raw.length);
        token.tokens = Lexer.lex(token.text)
        tokens.push(token);
        continue;
      }

      // LINE BREAK
      if (token = this.tokenizer.line_break(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      
      // LINK_SAMETAB
      if (token = this.tokenizer.link_sametab(src)) {
        src = src.replace(token.raw,'');
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }
      
      


      // LINK
      if (token = this.tokenizer.link(src)) {
        src = src.replace(token.raw,'');
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // REF
      if (token = this.tokenizer.ref(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // BOLD_ITALIC
      if (token = this.tokenizer.bold_italic(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // BOLD
      if (token = this.tokenizer.bold(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // ITALIC
      if (token = this.tokenizer.italic(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // STRIKETHROUGH

      if (token = this.tokenizer.strikethrough(src)) {
        src = src.substring(token.raw.length);
        token.tokensPrevious = Lexer.lex(token.previous);
        token.tokensText = Lexer.lex(token.text)
        token.tokensNext = Lexer.lex(token.next)
        tokens.push(token);
        continue;
      }

      // TEXT
      if (token = this.tokenizer.text(src)) {
        tokens.push(token);
        break;
      }
      

      if(true){
        console.log("Sin match")
        break;
      }

    }

    return tokens;
  }

 


};

},{"./rules.js":7,"./tokenizer.js":8}],3:[function(require,module,exports){
const Lexer = require('./lexer.js');
const GeneratorHTML = require('./generator_html.js');
const RenderHTML = require('./render_html.js');
const ParserLATEX = require('./parser_latex.js');
const { block } = require('./rules.js');


function mdd(src, format) {
  
  var tokens;
  
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }


  // Realiza la operación
  try {

    dictionary_tokens = Lexer.lex(src);
    console.log(dictionary_tokens);
    dictionary_html = GeneratorHTML.generator(dictionary_tokens)
    console.log(dictionary_html);
    html = RenderHTML.render(dictionary_html);
    console.log(html);
    return html;
  
  } catch (e) {
    e.message += '\nHay un error en el sistema';
    throw e;
  }
}

module.exports = {transform: mdd};
},{"./generator_html.js":1,"./lexer.js":2,"./parser_latex.js":5,"./render_html.js":6,"./rules.js":7}],4:[function(require,module,exports){
  
/**
 * Parsing & Compiling
 */
module.exports = class ParserHTML {
  constructor() {
    
  }

  /**
   * Static Parse Method
   */
  static parse(tokens) {
    const parser = new ParserHTML();
    return parser.parse(tokens);
  }


  /**
   * Parse Loop
   */
  parse(tokens) {
    //console.log(tokens)
    let out = '';
    let i, token, txt;
    const l = tokens.length;

    for (i = 0; i < l; i++) {
      token = tokens[i];

      switch (token.type) {


        // language
        case 'language': {
          txt= 'lang='+token.language;
          out += txt;
          continue;
        }

        // cover
        case 'cover': {
          txt='<img src="'+token.cover+'" alt="cover" width="100%"></img>\n';
          out += txt;
          continue;
        }


        // title
        case 'title': {
          txt='  <title>'+ token.title + '</title>\n';
          out += txt;
          continue;
        }

        // favicon
         case 'favicon': {
          txt='  <link rel="icon" type="image/x-icon"  href="'+ token.favicon + '">\n';
          out += txt;
          continue;
        }

        // css
        case 'css': {
          txt='  <link rel="stylesheet"  href="'+ token.css + '">\n';
          out += txt;
          continue;
        }

        // footer
        case 'footer': {
          var interior="";
          for (let x in token.internal){
            interior=interior+ '    '+ ParserHTML.parse(token.internal[x])+'\n';
          }
          txt='\n<footer>\n    '+ interior +'\n</footer>\n\n';
          out += txt;
          continue;
        }

        // navbar
        case 'navbar': {
          var interior="";
          for (let x in token.internal){
            interior=interior+ '    '+ ParserHTML.parse(token.internal[x])+'\n';
          }
          txt='\n<div class="topnav">\n   <div>\n'+ interior +'   </div>\n</div>\n\n';
          out += txt;
          continue;
        }

        // meta
        case 'meta': {
          txt='  <meta name="'+ token.meta + '" content="'+token.information+'">\n';
          out += txt;
          continue;
        }

        // body
        case 'body': {
          const interior= ParserHTML.parse(token.internal)
          txt=interior;
          out += txt;
          continue;
        }

        case 'article_note': {
          //console.log(token)
          const interior= ParserHTML.parse(token.tokens);
          txt='<div class="details">\n<details>\n  <summary>'+token.title+'</summary>\n<div>\n'+interior+'</div>\n</details>\n</div>\n\n';
          out += txt;
          continue;
        }

        case 'heading_description': {
          const title= ParserHTML.parse(token.tokens_title)
          const description= ParserHTML.parse(token.tokens_description);
          txt="  <div class='header'> <div class='title'>"+ title+ "</div> <div class='description'> " + description + "</div> </div>"
          out += txt;
          continue;
        }


    

        case 'heading': {
          const interior= ParserHTML.parse(token.tokens)
          txt='  <h' + token.depth + '>' + interior + '</h' + token.depth + '>\n';
          out += txt;
          continue;
        }

        case 'audio': {
          txt='<div class="audio">\n<audio controls>\n<source src="'+token.link+'" alt="'+token.title+'"type="audio/mpeg">\n</audio>\n</div>';
          out += txt;
          continue;
        }

        case 'image_link_sametab': {
          txt='<a class="imageButton" href="'+token.external+'"><img src="'+token.link+'" alt="'+token.title+'"width="'+token.width+'"></img></a>\n';
          out += txt;
          continue;
        }

        case 'image_link': {
          txt='<a target="_blank" href="'+token.external+'"><img src="'+token.link+'" alt="'+token.title+'"width="'+token.width+'"></img></a>\n';
          out += txt;
          continue;
        }

        case 'image_caption': {
          txt='<figure>\n<img src="'+token.link+'" alt="'+token.title+'"width="'+token.width+'">\n<figcaption>'+token.note+'</figcaption>\n</figure>\n';
          out += txt;
          continue;
        }

        case 'image_no_caption': {
          txt='<img src="'+token.link+'" alt="'+token.title+'"width="'+token.width+'"></img>\n';
          out += txt;
          continue;
        }

        case 'image_cover': {
          continue;
        }

        case 'blockquote': {
          const interior=ParserHTML.parse(token.tokens);
          txt='  <blockquote>\n<div>\n' +interior+'\n</div>\n</blockquote>\n';
          out += txt;
          continue;
        }

        case 'comment': {
          txt='<div class="comment"\n'+ token.text+'\n</div>';
          out += txt;
          continue;
        }


        case 'list1': {
          var interior="";
          console.log("LEER ACA")
          console.log(token.internal);
          for (let x in token.internal){
            interior=interior+ '    <li>'+ ParserHTML.parse(token.internal[x])+'  </li>\n';
          }
          txt='  <ul>\n' +interior+'  </ul>\n';
          out += txt;
          continue;
        }



        case 'note': {
          const interior= ParserHTML.parse(token.tokens);
          txt='<p id="n'+token.id+'">'+token.id+". "+interior +'<a class="ref" href="#ref'+token.id+'">&#8617</a></p>\n';
          out += txt;
          continue;
        }

        case 'marker': {
          txt='<div class="marker">* * *</div>\n';
          out += txt;
          continue;
        }

        case 'paragraph': {
          const interior= ParserHTML.parse(token.tokens);
          txt='  <p>' +interior +'</p>\n';
          out += txt;
          continue;
        }

        case 'line_break': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<br>'+next;
          out += txt;
          continue;
        }
  

        case 'bold': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<b>'+text+'</b>'+next;
          out += txt;
          continue;
        }

        case 'link_sametab': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<a href="'+token.link+'">'+token.title+'</a>'+next;
          out += txt;
          continue;
        }

        case 'link': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<a href="'+token.link+'" target="_blank">'+token.title+'</a>'+next;
          out += txt;
          continue;
        }


        case 'ref': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<a class="ref" href="#n'+token.id+'" id="ref'+token.id+'">'+text+'<sup>'+token.id+'</sup></a>'+next;
          out += txt;
          continue;
        }


        case 'bold_italic': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<b><i>'+text+'</i></b>'+next;
          out += txt;
          continue;
        }

        case 'bold': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<b>'+text+'</b>'+next;
          out += txt;
          continue;
        }

        case 'italic': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<i>'+text+'</i>'+next;
          out += txt;
          continue;
        }

        case 'strikethrough': {
          const previous= ParserHTML.parse(token.tokensPrevious)
          const text= ParserHTML.parse(token.tokensText);
          const next= ParserHTML.parse(token.tokensNext);
          txt=previous+'<del>'+text+'</del>'+next;
          out += txt;
          continue;
        }

        case 'text': {
          out += token.text;
          continue;
        }
        


      }
    }

    return out;
  }


};

},{}],5:[function(require,module,exports){
  
/**
 * Parsing & Compiling
 */
module.exports = class ParserLATEX {
  constructor() {
    
  }

  /**
   * Static Parse Method
   */
  static parse(tokens) {
    const parser = new ParserLATEX();
    return parser.parse(tokens);
  }


  /**
   * Parse Loop
   */
  parse(tokens) {
    let out = '';
    let i, token, txt, sect,size;
    const l = tokens.length;

    for (i = 0; i < l; i++) {
      token = tokens[i];

      switch (token.type) {

        case 'document': {
          const interior= ParserLATEX.parse(token.tokens)
          txt='\\begin{document}\n\n'+interior+'\\end{document}'
          out += txt;
          continue;
        }

        case 'metadata': {
          const interiorBody= ParserLATEX.parse(token.tokens2)
          txt=interiorBody
          out += txt;
          continue;
        }

        case 'literature': {
          const interior= ParserLATEX.parse(token.tokens)
          txt=interior;
          out += txt;
          continue;
        }

        case 'details': {
          // \chapter{Let's begin}
          const interior= ParserLATEX.parse(token.tokens);
          txt='\\section*{'+token.title+'}\n\n'+interior;
          out += txt;
          continue;
        }

        
        case 'heading': {
          if(token.depth==1) {sect= "\\section*{"}
          if(token.depth==2) {sect= "\\subsection*{"}
          if(token.depth>=3) {sect= "\\subsubsection*{"}
          txt=sect + token.text + '}\n\n';
          out += txt;
          continue;
        }

        case 'image_caption': {

          if(token.width.slice(token.width.length - 1)=="%"){
            size= parseInt(token.width)/100+"\\textwidth";
          }

          else{
            size=token.width;
          }
          
          txt= "\\begin{figure}[htb]\n \\centering \n \\includegraphics[width="+size+"]{"+token.link+"}\n \\caption{"+token.note+"}\n\\end{figure}\n\n"
          out += txt;
          continue;
        }

        case 'image_no_caption': {
          continue;
        }

        case 'image_cover': {
          txt="\\includepdf{"+token.link+"}\n\n";
          out += txt;
          continue;
        }

        case 'poem': {
          const interior= ParserLATEX.parse(token.tokens);
          txt=interior;
          out += txt;
          continue;
        }
        

        case 'note': {
          const interior= ParserLATEX.parse(token.tokens);
          txt=interior;
          out += txt;
          continue;
        }

        case 'paragraph': {
          const interior= ParserLATEX.parse(token.tokens);
          txt='\\par '+ interior+ '\n\n';
          out += txt;
          continue;
        }

        case 'link': {
          continue;
        }


        case 'ref': {
          const previous= ParserLATEX.parse(token.tokensPrevious)
          const text= ParserLATEX.parse(token.tokensText);
          const next= ParserLATEX.parse(token.tokensNext);
          txt=previous+text+next;
          out += txt;
          continue;
        }


        case 'bold_italic': {
          const previous= ParserLATEX.parse(token.tokensPrevious)
          const text= ParserLATEX.parse(token.tokensText);
          const next= ParserLATEX.parse(token.tokensNext);
          txt=previous+'\\textbf{\\textit{'+text+'}}'+next;
          out += txt;
          continue;
        }

        case 'bold': {
          const previous= ParserLATEX.parse(token.tokensPrevious)
          const text= ParserLATEX.parse(token.tokensText);
          const next= ParserLATEX.parse(token.tokensNext);
          txt=previous+'\\textbf{'+text+'}'+next;
          out += txt;
          continue;
        }

        case 'italic': {
          const previous= ParserLATEX.parse(token.tokensPrevious)
          const text= ParserLATEX.parse(token.tokensText);
          const next= ParserLATEX.parse(token.tokensNext);
          txt=previous+'\\textit{'+text+'}'+next;
          out += txt;
          continue;
        }

        case 'text': {
          out += token.text;
          continue;
        }

        continue;
        


      }
    }

    return out;
  }


};

},{}],6:[function(require,module,exports){
const ParserHTML = require('./parser_html.js');

/**
 * Parsing & Compiling
 */
module.exports = class RenderHTML {
  constructor() {
    
  }

  /**
   * Static Parse Method
   */
  static render(tokens) {

    var metadata='  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n';
    var language="";
    var navbar=""
    var cover=""
    var body="";
    var article_notes="";
    var footer="";

    for (var x in tokens){

      if (tokens[x].type=="language"){
        language=tokens[x].html;
        continue;
      }
  
      if (tokens[x].type=="css"){
        metadata=metadata+tokens[x].html;
        continue;
      }

      if (tokens[x].type=="favicon"){
        metadata=metadata+tokens[x].html;
        continue;
      }
  
      if (tokens[x].type=="title"){
        metadata=metadata+tokens[x].html;
        continue;
      }
   
      if (tokens[x].type=="meta"){
        metadata=metadata+tokens[x].html;
        continue;
      }

      if (tokens[x].type=="navbar"){
        navbar=navbar+tokens[x].html;
        continue;
      }

      if (tokens[x].type=="cover"){
        cover=cover+tokens[x].html;
        continue;
      }

      if (tokens[x].type=="body"){
        body=body+"<div class='literature'>"+tokens[x].html+"\n</div>\n";
        continue;
      }

      if (tokens[x].type=="article_note"){
        article_notes=article_notes+tokens[x].html;
        continue;
      }

      if (tokens[x].type=="footer"){
        footer=footer+tokens[x].html;
        continue;
      }
    }


    let out = '<!DOCTYPE html>\n<html '+language+'>\n\n<head>\n'+metadata +'<head>\n\n<body>\n'+navbar+cover+body+article_notes+footer+ '\n</body>\n</html>';
    return out;
  }


};

},{"./parser_html.js":4}],7:[function(require,module,exports){

/**
 * Block-Level Grammar
 */
const block = {

  language: /\s*---\n[\s\S]+(LANGUAGE:([^\n]*))[\s\S]*?---/,
  cover: /\s*---\n[\s\S]+(COVER:([^\n]*))[\s\S]*?---/,
  favicon: /\s*---\n[\s\S]+(FAVICON:([^\n]*))[\s\S]*?---/,
  title: /\s*---\n[\s\S]+(TITLE:([^\n]*))[\s\S]*?---/,
  css: /\s*---\n[\s\S]+(CSS:([^\n]*))[\s\S]*?---/,
  footer: /\s*---\n[\s\S]+(FOOTER:((\s*- [^\n]*)+))[\s\S]+?---\n/,
  navbar: /\s*---\n[\s\S]+(NAVBAR:((\s*- [^\n]*)+))[\s\S]+?---\n/,
  meta: /\s*---\n[\s\S]+\n(([\s\S]+):([^\n]*))[\s\S]*?---/,
  body: /\s*---\n+\s*---([\s\S]+)/,
  image_link_sametab: /^\s*!\[(.*?)]\((.*?)\)\((.*?)\)\((.*?)\){sametab}\s*/,
  image_link: /^\s*!\[(.*?)]\((.*?)\)\((.*?)\)\((.*?)\)\s*/,
  image_caption:/^\s*!\[(.*?)]\((.*?)\)\((.*?)\) *\n\*(.*)\*\s*/,
  image_no_caption:/^\s*!\[(.*?)]\((.*?)\)\((.*?)\)\s*/,
  image_cover:/^\s*!\[(.*?)]\s*/,
  audio:/^\s*!!\[(.*?)]\((.*?)\)\s*/,
  article_note: /\s*```+\s*note\s# (.*)\s*((.|\s)*?\n)```\s*/,
  heading_description: /^\s*(#{1,6}) +([^\n]*)(?<!\s)\s\n([^\n]*)/,
  heading: /^\s*(#{1,6}) +([^\n]*)(?<!\s)\s*/,
  blockquote:/^\s*(>[^\n]*(?:\n|$))+\s*/,
  comment:/^\s*```((?:\s|.)*?)```\s*/,
  list1:/^\s*((- [^\n]*(?:\n|$))+)\s\s+/,
  note:/^\s*\[\^(.*?)\]: (.*)\s*/,
  marker: /^\s*\* \* \*\s*/,
  paragraph:/^([\S\s]+?)\n\n+/,
  line_break:/(.*)\n(.*)/,
  link_sametab:/(.*)\[(.*?)]\((.*?)\){sametab}(.*)/,
  link:/(.*)\[(.*?)]\((.*?)\)(.*)/,
  ref: /^(.*)\<(.*?)\[\^(.*?)\]\>(.*)/,
  bold_italic: /(.*)\*\*\*(.*?)\*\*\*(.*)/,
  bold: /(.*)\*\*(.*?)\*\*(.*)/,
  italic: /(.*)\*(.*?)\*(.*)/,
  strikethrough: /(.*)\~\~(.*?)\~\~(.*)/

};


module.exports = {
  block,
};

},{}],8:[function(require,module,exports){
const { block } = require('./rules.js');

/**
 * Tokenizer
 */
module.exports = class Tokenizer {

  constructor() {
    this.rules=block;
  }

  language(src) {
    const cap = this.rules.language.exec(src);
    if (cap) {
      return {
        type: 'language',
        raw: cap[0], 
        metadata: cap[1], 
        language: cap[2], 
      };
    }
  }

  cover(src) {
    const cap = this.rules.cover.exec(src);
    if (cap) {
      return {
        type: 'cover',
        raw: cap[0], 
        metadata: cap[1], 
        cover: cap[2], 
      };
    }
  }

  title(src) {
    const cap = this.rules.title.exec(src);
    if (cap) {
      return {
        type: 'title',
        raw: cap[0], 
        metadata: cap[1], 
        title: cap[2], 
      };
    }
  }

  favicon(src) {
    const cap = this.rules.favicon.exec(src);
    if (cap) {
      return {
        type: 'favicon',
        raw: cap[0], 
        metadata: cap[1], 
        favicon: cap[2], 
      };
    }
  }

  css(src) {
    const cap = this.rules.css.exec(src);
    if (cap) {
      return {
        type: 'css',
        raw: cap[0], 
        metadata: cap[1], 
        css: cap[2], 
      };
    }
  }

  footer(src) {
    const cap = this.rules.footer.exec(src);
    if (cap) {
      return {
        type: 'footer',
        raw: cap[0], 
        information: cap[1], 
        list: cap[2], 
      };
    }
  }

  navbar(src) {
    const cap = this.rules.navbar.exec(src);
    if (cap) {
      return {
        type: 'navbar',
        raw: cap[0], 
        information: cap[1], 
        list: cap[2], 
      };
    }
  }

  meta(src) {
    const cap = this.rules.meta.exec(src);
    if (cap) {
      return {
        type: 'meta',
        raw: cap[0],
        metadata: cap[1],
        meta: cap[2],
        information: cap[3],
      };
    }
  }

  body(src) {
    const cap = this.rules.body.exec(src);
    if (cap) {
      return {
        type: 'body',
        raw: cap[0],
        body: cap[1]
      };
    }
  }


  article_note(src){
    const cap = this.rules.article_note.exec(src);
    if (cap) {
      return {
        type: 'article_note',
        raw: cap[0],
        title: cap[1],
        text: cap[2]
      };
    }
  }


  heading_description(src) {
    const cap = this.rules.heading_description.exec(src);
    if (cap) {
      return {
        type: 'heading_description',
        raw: cap[0],
        depth: cap[1].length,
        text: cap[2],
        description: cap[3]
      };
    }
  }

  heading(src) {
    const cap = this.rules.heading.exec(src);
    if (cap) {
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[1].length,
        text: cap[2]
      };
    }
  }

  audio(src) {
    const cap = this.rules.audio.exec(src);
    if (cap) {
      return {
        type: 'audio',
        raw: cap[0],
        title: cap[1],
        link: cap[2]
      };
    }
  }

  image_link_sametab(src) {
    const cap = this.rules.image_link_sametab.exec(src);
    if (cap) {
      return {
        type: 'image_link_sametab',
        raw: cap[0],
        title: cap[1],
        link:cap[2],
        width:cap[3],
        external:cap[4]
      };
    }
  }

  image_link(src) {
    const cap = this.rules.image_link.exec(src);
    if (cap) {
      return {
        type: 'image_link',
        raw: cap[0],
        title: cap[1],
        link:cap[2],
        width:cap[3],
        external:cap[4]
      };
    }
  }


  image_caption(src) {
    const cap = this.rules.image_caption.exec(src);
    if (cap) {
      return {
        type: 'image_caption',
        raw: cap[0],
        title: cap[1],
        link:cap[2],
        width:cap[3],
        note:cap[4]
      };
    }
  }

  image_no_caption(src) {
    const cap = this.rules.image_no_caption.exec(src);
    if (cap) {
      return {
        type: 'image_no_caption',
        raw: cap[0],
        title: cap[1],
        link:cap[2],
        width:cap[3]
      };
    }
  }

  image_cover(src) {
    const cap = this.rules.image_cover.exec(src);
    if (cap) {
      return {
        type: 'image_cover',
        raw: cap[0],
        link:cap[1]
      };
    }
  }


  blockquote(src) {
    const cap = this.rules.blockquote.exec(src);
    if (cap) {
      const text3= cap[0].replace(/> /gm, '');
      const text = text3.replace(/>/gm, '');

      return {
        type: 'blockquote',
        raw: cap[0],
        text
      };
    }
  }

  comment(src) {
    const cap = this.rules.comment.exec(src);
    if (cap) {
      const text= cap[1].replace(/\</gm, "&lt;").replace(/\n/gm, "<br>").replace(/ /gm, "&nbsp;");;

      return {
        type: 'comment',
        raw: cap[0],
        text: text
      };
    }
  }

  list1(src) {
    const cap = this.rules.list1.exec(src);
    if (cap) {
      return {
        type: 'list1',
        raw: cap[0],
        list: cap[1],
      };
    }
  }


  note(src) {
    const cap = this.rules.note.exec(src);
    if (cap) {
      return {
        type: 'note',
        raw: cap[0],
        id: cap[1],
        text: cap[2]
      };
    }
  }

  marker(src) {
    const cap = this.rules.marker.exec(src);
    if (cap) {
      return {
        type: 'marker',
        raw: cap[0]
      };
    }
  }



  paragraph(src) {
    const cap = this.rules.paragraph.exec(src);
    if (cap) {
      return {
        type: 'paragraph',
        raw: cap[0],
        text: cap[1]
      };
    }
  }

  line_break(src) {
    const cap = this.rules.line_break.exec(src);
    if (cap) {
      return {
        type: 'line_break',
        raw: cap[0],
        previous: cap[1],
        next: cap[2],
      };
    }
  }

  link_sametab(src) {
    const cap = this.rules.link_sametab.exec(src);
    if (cap) {

      if(cap[2]==''){
        cap[2]=cap[3];
      }

      return {
        type: 'link_sametab',
        raw: cap[0],
        previous: cap[1],
        title:cap[2],
        link:cap[3],
        next: cap[4],
      };
    }
  }

  link(src) {
    const cap = this.rules.link.exec(src);
    if (cap) {

      if(cap[2]==''){
        cap[2]=cap[3];
      }

      return {
        type: 'link',
        raw: cap[0],
        previous: cap[1],
        title:cap[2],
        link:cap[3],
        next: cap[4],
      };
    }
  }

  ref(src) {
    const cap = this.rules.ref.exec(src);
    if (cap) {
      return {
        type: 'ref',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        id: cap[3],
        next: cap[4],
      };
    }
  }

  bold_italic(src) {
    const cap = this.rules.bold_italic.exec(src);
    if (cap) {
      return {
        type: 'bold_italic',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        next: cap[3],
      };
    }
  }

  bold(src) {
    const cap = this.rules.bold.exec(src);
    if (cap) {
      return {
        type: 'bold',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        next: cap[3],
      };
    }
  }

  italic(src) {
    const cap = this.rules.italic.exec(src);
    if (cap) {
      return {
        type: 'italic',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        next: cap[3],
      };
    }
  }

  strikethrough(src) {
    const cap = this.rules.strikethrough.exec(src);
    if (cap) {
      return {
        type: 'strikethrough',
        raw: cap[0],
        previous: cap[1],
        text: cap[2],
        next: cap[3],
      };
    }
  }

  text(src) {
      return {
        type: 'text',
        raw: src,
        text: src
      };
  }


};

},{"./rules.js":7}]},{},[3])(3)
});
